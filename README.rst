This directory contains a tool to compress an executable file by 20-25%.

Quickstart
----------

To compile::

   make

To run the example::

   make decompress.xe

To run it on your own code::

   xobjdump --split --strip file.xe
   ./compressor -b 0x10000 -t 0x18000 image_n0c0.bin -o decompress.xe -target=XK-1

The file ``decompress.xe`` is an executable that will execute at address
0x10000. This executable will place the uncompressed binary at address
0x18000, and jump to address 0x18000. You can use this to, for example,
store a compressed program in OTP.

The detail
----------

The program is inspired by the liblzg project by Marcus Geelnard,
<http://liblzg.bitsnbites.eu/>. The compression algorithm is slightly
simplified, but has been written from scratch to make sure that the
decompression is be space efficient on XMOS processors, and necessarily
speed efficient. The decompressor is generated by the compressor
(typically around 120 bytes), together with the compressed binary as a
single assembly file.

The compressed binary is a sequence of bytes that are mostly the original
binary, but where sequences have been repeated, these sequences are
replaced with a command in the compressed file to copy the sequence from an
earlier spot. There are three commands to achieve this:

* command 0: copies a long sequence over a short distance

* command 1: copies a short sequence over a medium distance

* command 2: copies a long sequence over a long distance

Command 0 comprises a marker symbol (called marker0), and a byte that
contains the length of the sequence encoded in the top few bits, and the
distance encoded in the bottom few bits. The length encoding subtracts 3
(so bits '000000' means that the length of the sequence is 3, and bits
'000110' means that the length of the sequence is 9), and the distance
encoding divides by 2 (so bits '01' means that the sequence is 2 bytes in
the past, and bits '11' means that the sequence is 6 bytes in the past).
The number of bits for length and distance is determined at compression
time, and encoded in the decompressor binary.

Command 1 is very similar to Command 0, but uses a different trade-off in
the number of bits allocated to length and position. It comprises a marker symbol
(called marker1), and a byte that contains the length of the sequence
encoded in the top few bits, and the distance encoded in the bottom few
bits. The length encoding subtracts 3 (so bits '00' means that the length
of the sequence is 3, and bits '10' means that the length of the sequence
is 5), and the distance encoding divides by 2 and subtracts the maximum
distance encoding for Command 1 (so, assuming that command 0 can span 6
bytes, bits '000001' means that the sequence is 8 bytes in the past, and
bits '000011' means that the sequence is 12 bytes in the past). As with
command 0, the number of bits for length and distance is determined at
compression time, and encoded in the decompressor binary.

Command 2 uses two bytes for its encoding, and a symbol called marker2. The
second byte is the LSB of the distance, and the most significant bits and
length are encoded in the first byte. The offsets and encodings are as in
Command 1, but the split is again determined at compression time.

The values for marker0, marker1, and marker2 are also established at
compression time, and are either values that do not occur in the binary, or
otherwise values that occur least frequently. If the value should occur,
then the marker symbol followed by value '0' is an escape to insert the
marker symbol.

The compressor
--------------

The compression engine tries all sensible bit splits in Command 0, 1, and
2, and searches the whole program for longest matching lengths. Once it has
explored the space, it generates a compressed binary and an assembly file
containing the compressor with the correct marker-values, bit splits, and
compressed binary. The binary is padded with an extra '0' byte if the
number of bytes is an odd number.

The assembly file is then compiled into a ``.xe`` binary, and this binary
is executed using the simulator to verify that it produces the expected
original binary. Any errors are reported.

The process takes a few seconds.

The decompressor
----------------

The decompressor is a piece of assembly code that interprets the binary.
The target address, marker values, and bit splits are all hard coded in the
assembly code.

The decompressor is position independent and can execute at any address.
The target address is the address at which the target code expects to run.


Further optimisations
---------------------

* A fourth marker could be used to occupy the medium sequences over a medium
  distance - this adds 16 bytes or so the the encoder, and saves 60 bytes or
  so in the binary.

* The compressor could try 1 or more markers, each with 1 or 2 bytes
  sequences, and pick the shortest sequence (including the code for
  decoding, which grows with more markers)

* A test could be made whether any markers occur in the binary - if not,
  the test for escape characters can be omitted.
